# -*- coding: utf-8 -*-
"""GenerarPrecios.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/13czlDP9pzmqtr7VzroRBE5_MU5xUQKU3
"""

def GeneraPrecios(Ruta_JSON,GuardarData = False):

  #Importacion de paqueterias
  import polars as pl
  import numpy as np
  import json
  from scipy import stats
  from statistics import mean

  #Importamos el archivo y lo volvemos un polars
  with open(Ruta_JSON, 'r') as file:
    parsed_data = [json.loads(line) for line in file]
  datos= pl.DataFrame(parsed_data)

  #Quitamos las columnas innecesarias
  datos=datos.drop(["campos_adicionales"])

  #Esta funcion es la que normaliza los nombres con el geopandas
  def Unificar(Nombre):
    conversion = {
        'azcapotzalco': 'Azcapotzalco',
        'benito-juarez': 'Benito Juárez',
        'coyoacan': 'Coyoacán',
        'cuajimalpa-de-morelos': 'Cuajimalpa de Morelos',
        'gustavo-a-madero': 'Gustavo A. Madero',
        'miguel-hidalgo': 'Miguel Hidalgo',
        'tlahuac': 'Tláhuac',
        'iztacalco': 'Iztacalco',
        'iztapalapa': 'Iztapalapa',
        'venustiano-carranza': 'Venustiano Carranza',
        'la-magdalena-contreras': 'La Magdalena Contreras',
        'alvaro-obregon': 'Álvaro Obregón',
        'cuauhtemoc': 'Cuauhtémoc',
        'milpa-alta': 'Milpa Alta',
        'xochimilco': 'Xochimilco',
        'tlalpan': 'Tlalpan',
        'venustiano carranza': 'Venustiano Carranza',
        'xochimilco': 'Xochimilco',
        'coyoacan': 'Coyoacán',
        'azcapotzalco': 'Azcapotzalco',
        'alvaro obregon': 'Álvaro Obregón',
        'iztapalapa': 'Iztapalapa',
        'miguel hidalgo': 'Miguel Hidalgo',
        'benito juarez': 'Benito Juárez',
        'gustavo a. madero': 'Gustavo A. Madero',
        'cuauhtemoc': 'Cuauhtémoc',
        'tlalpan': 'Tlalpan',
        'iztacalco': 'Iztacalco',
        'cuajimalpa': 'Cuajimalpa de Morelos',
        'magdalena contreras': 'La Magdalena Contreras',
        'tlahuac': 'Tláhuac',
        'milpa alta': 'Milpa Alta'
    }
    return conversion.get(Nombre, Nombre)

  datos = datos.with_columns(
  pl.col("delegacion").map_elements(Unificar).alias("delegacion")
  )
  #En este punto el dataframe tiene los nombres correctos

  #Quitamos las columnas con muchos valores nulos
  def ElimNulos(df, umbral=0.8):
    proporciones_nulos = df.null_count() / df.height
    columnas_a_conservar = [
        columna for columna, porcentaje in zip(proporciones_nulos.columns, proporciones_nulos.row(0))
        if porcentaje <= umbral
    ]
    return df.select(columnas_a_conservar)

  datos=ElimNulos(datos)
  #Ya tenemos un dataframe sin muchos valores nulos (posiblemente ninguno)

  #Hasta aqui va bien

  #Cramos una funcion que calcula los limites superior e inferior para cada columna
  def Limites(datacolumn,z=1.5):
    sorted(datacolumn)
    Q1,Q3=np.nanpercentile(datacolumn,[25,75])
    IQR=Q3-Q1
    lower_range= Q1-(z * IQR)
    upper_range= Q3+(z * IQR)
    return lower_range, upper_range

  #Crearemos esta copia para calcular el IQR de cada caracteristica sin que se vea afectado por la eliminacion de atipicos de otras
  Copia=datos.clone()

  #Hacemos un ciclo que entre a limpiar los atipicos de cada delegacion
  Delegaciones=datos["delegacion"].unique()

  for Del in Delegaciones:
      # Filtrar los precios de la delegación actual
      precio_delegacion = datos.filter(pl.col("delegacion") == Del)["precio"]

      # Calcular los límites para la delegación
      Inf, Sup = Limites(precio_delegacion)

      # Crear la máscara; Permanece si: No es de esa delegacion o esta dentro de los limites
      Mascara = (datos["delegacion"] != Del) | ((datos["precio"] <= Sup) & (datos["precio"] >= Inf))

      # Aplicar la máscara para filtrar los datos
      datos = datos.filter(Mascara)

    # Obtener las columnas numéricas del DataFrame (omitimos precio)
  Caracteristicas = [col for col in datos.columns if datos[col].dtype in [pl.Int32, pl.Int64, pl.Float32, pl.Float64]][1:]

  for Car in Caracteristicas:
      # Filtrar la columna para excluir los valores nulos en los cálculos de límites
      precio_columna = Copia[Car].filter(Copia[Car].is_not_null())

      # Calcular los límites usando la función Limites
      Inf, Sup = Limites(precio_columna)

      # Crear la máscara de validación para esa columna, excluyendo los nulos
      Mascara = (datos[Car] <= Sup) & (datos[Car] >= Inf) | datos[Car].is_null()

      # Aplicar el filtro a los datos
      datos = datos.filter(Mascara)

  medianas=[] #Vamos a guardar las medianas, nos seran utiles despues
  Caracteristicas = ["precio",'superficie_de_terreno', 'superficie_construida', 'recamaras', 'baños', 'estacionamiento']
  for i in range(len(Caracteristicas)):
      col = Caracteristicas[i]
      seleccion = datos[col].filter(datos[col].is_not_null())
      values = seleccion.to_list()
      mean_val = np.mean(values)  #Calculamos media
      median_val = np.median(values) #Calculamos mediana
      medianas.append((Caracteristicas[i],median_val)) #Guardamos la mediana

  #Ahora eliminamos los valores nulos
  for col,median in medianas:
    datos=datos.with_columns(pl.when(pl.col(col).is_null()).then(median).otherwise(pl.col(col)).alias(col))


  #Guardamos el dataframe en JSON (Opcional , solo si GuardarData==True)
  if GuardarData==True:
    datos.to_pandas().to_json(Ruta_JSON[:19]+"_cleaned"+".jsonl", orient="records", lines=True)


  #Aqui hacemos todo
  dfAuxiliar=datos.to_pandas().groupby("delegacion")["precio"].median().reset_index()
  Delegacion=dfAuxiliar["delegacion"].to_list()
  Costo=dfAuxiliar["precio"].to_list()
  #Guardamos los datos

  return  dict(zip(Delegacion,Costo))