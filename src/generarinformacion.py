# -*- coding: utf-8 -*-
"""GenerarInformacion.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1UQYnlR0NQoUgTwVUS3Q_ZOCSUi9DlRWA
"""

#Primero debo importar el JSON

def GenerarInformacion(Ruta_JSON,Nombre_Folder="Informacion"):

  #Importacion de paqueterias
  import os
  import polars as pl
  import numpy as np
  import matplotlib.pyplot as plt
  import seaborn as sns
  import json
  from scipy import stats
  from statistics import mean
  import shutil

  #Creamos el folder donde iremos guardando todo, por default se llamara Informacion
  NombreCarpeta=Nombre_Folder
  if os.path.exists(NombreCarpeta):
        shutil.rmtree(NombreCarpeta)
  os.makedirs(NombreCarpeta, exist_ok=True)  # Crea la carpeta si no existe

  ruta_Carpeta=os.path.abspath(NombreCarpeta)
  #Vamos a crear tambien un array con las direcciones de las imagenes que vayamos guardando (Valores)
  DireccionesImagenes=[]

  #Otro con el nombre de las imagenes (Llaves)
  NombresImagenes=[]

  #Importamos el archivo y lo volvemos un polars
  with open(Ruta_JSON, 'r') as file:
    parsed_data = [json.loads(line) for line in file]
  datos= pl.DataFrame(parsed_data)

  #Quitamos las columnas innecesarias
  datos=datos.drop(["campos_adicionales"])

  #Esta funcion es la que normaliza los nombres con el geopandas
  def Unificar(Nombre):
    conversion = {
        'azcapotzalco': 'Azcapotzalco',
        'benito-juarez': 'Benito Juárez',
        'coyoacan': 'Coyoacán',
        'cuajimalpa-de-morelos': 'Cuajimalpa de Morelos',
        'gustavo-a-madero': 'Gustavo A. Madero',
        'miguel-hidalgo': 'Miguel Hidalgo',
        'tlahuac': 'Tláhuac',
        'iztacalco': 'Iztacalco',
        'iztapalapa': 'Iztapalapa',
        'venustiano-carranza': 'Venustiano Carranza',
        'la-magdalena-contreras': 'La Magdalena Contreras',
        'alvaro-obregon': 'Álvaro Obregón',
        'cuauhtemoc': 'Cuauhtémoc',
        'milpa-alta': 'Milpa Alta',
        'xochimilco': 'Xochimilco',
        'tlalpan': 'Tlalpan',
        'venustiano carranza': 'Venustiano Carranza',
        'xochimilco': 'Xochimilco',
        'coyoacan': 'Coyoacán',
        'azcapotzalco': 'Azcapotzalco',
        'alvaro obregon': 'Álvaro Obregón',
        'iztapalapa': 'Iztapalapa',
        'miguel hidalgo': 'Miguel Hidalgo',
        'benito juarez': 'Benito Juárez',
        'gustavo a. madero': 'Gustavo A. Madero',
        'cuauhtemoc': 'Cuauhtémoc',
        'tlalpan': 'Tlalpan',
        'iztacalco': 'Iztacalco',
        'cuajimalpa': 'Cuajimalpa de Morelos',
        'magdalena contreras': 'La Magdalena Contreras',
        'tlahuac': 'Tláhuac',
        'milpa alta': 'Milpa Alta'
    }
    return conversion.get(Nombre, Nombre)

  datos = datos.with_columns(
  pl.col("delegacion").map_elements(Unificar).alias("delegacion")
  )
  #En este punto el dataframe tiene los nombres correctos

  #Quitamos las columnas con muchos valores nulos
  def ElimNulos(df, umbral=0.8):
    proporciones_nulos = df.null_count() / df.height
    columnas_a_conservar = [
        columna for columna, porcentaje in zip(proporciones_nulos.columns, proporciones_nulos.row(0))
        if porcentaje <= umbral
    ]
    return df.select(columnas_a_conservar)

  datos=ElimNulos(datos)
  #Ya tenemos un dataframe sin muchos valores nulos (posiblemente ninguno)

  #Esta es la funcion que guarda imagenes en el folder
  def GuardarImagen(Nombre_de_imagen,Direccion_Folder=ruta_Carpeta,):
    # Ruta completa para guardar la imagen
    ruta_imagen = os.path.join(Direccion_Folder, Nombre_de_imagen+".jpg")

    # Guardar la imagen actual
    plt.savefig(ruta_imagen, format="jpg")
    plt.close()  # Cerrar la figura para liberar memoria
    return ruta_imagen


  #Ahora haremos los graficos de los boxplots antes de las caracteristicas antes de ser limpiadas

  columnas = ['precio',
            'superficie_de_terreno',
            'superficie_construida',
            'recamaras',
            'baños',
            'estacionamiento']

  for col in columnas:
      values = datos[col].to_list()
      plt.figure(figsize=(8, 6))
      sns.boxplot(x=values)
      #Guardamos el nombre de la imagen
      Nombre_de_imagen=f'Boxplot de {col} inicial'
      NombresImagenes.append(Nombre_de_imagen)
      plt.title(Nombre_de_imagen)
      plt.ylabel('Valores')
      plt.xlabel(col)
      plt.grid()
      plt.tight_layout()
      #Guardamos la direccion de la imagen
      DireccionesImagenes.append(GuardarImagen(Nombre_de_imagen))

  #Hasta aqui va bien


  #Ahora guardamos la imagen de los atipicos por delegacion antes de la limpieza
  plt.figure(figsize=(10,10))
  sns.boxplot(data=datos.to_pandas(),x="precio",y="delegacion")
  Nombre_de_imagen="Boxplot de precios por delegacion"
  NombresImagenes.append(Nombre_de_imagen)
  plt.title(Nombre_de_imagen)
  plt.ylabel('Precio')
  plt.xlabel('Delegación')
  DireccionesImagenes.append(GuardarImagen(Nombre_de_imagen))

  #Cramos una funcion que calcula los limites superior e inferior para cada columna
  def Limites(datacolumn,z=1.5):
    sorted(datacolumn)
    Q1,Q3=np.nanpercentile(datacolumn,[25,75])
    IQR=Q3-Q1
    lower_range= Q1-(z * IQR)
    upper_range= Q3+(z * IQR)
    return lower_range, upper_range

  #Crearemos esta copia para calcular el IQR de cada caracteristica sin que se vea afectado por la eliminacion de atipicos de otras
  Copia=datos.clone()

  #Hacemos un ciclo que entre a limpiar los atipicos de cada delegacion
  Delegaciones=datos["delegacion"].unique()

  for Del in Delegaciones:
      # Filtrar los precios de la delegación actual
      precio_delegacion = datos.filter(pl.col("delegacion") == Del)["precio"]

      # Calcular los límites para la delegación
      Inf, Sup = Limites(precio_delegacion)

      # Crear la máscara; Permanece si: No es de esa delegacion o esta dentro de los limites
      Mascara = (datos["delegacion"] != Del) | ((datos["precio"] <= Sup) & (datos["precio"] >= Inf))

      # Aplicar la máscara para filtrar los datos
      datos = datos.filter(Mascara)

    # Obtener las columnas numéricas del DataFrame (omitimos precio)
  Caracteristicas = [col for col in datos.columns if datos[col].dtype in [pl.Int32, pl.Int64, pl.Float32, pl.Float64]][1:]

  for Car in Caracteristicas:
      # Filtrar la columna para excluir los valores nulos en los cálculos de límites
      precio_columna = Copia[Car].filter(Copia[Car].is_not_null())

      # Calcular los límites usando la función Limites
      Inf, Sup = Limites(precio_columna)

      # Crear la máscara de validación para esa columna, excluyendo los nulos
      Mascara = (datos[Car] <= Sup) & (datos[Car] >= Inf) | datos[Car].is_null()

      # Aplicar el filtro a los datos
      datos = datos.filter(Mascara)

  #Ploteamos las distribuciones sin atipicos
  medianas=[] #Vamos a guardar las medianas, nos seran utiles despues
  Caracteristicas = ["precio",'superficie_de_terreno', 'superficie_construida', 'recamaras', 'baños', 'estacionamiento']
  colors = sns.color_palette("Set2", 6)
  for i in range(len(Caracteristicas)):
      col = Caracteristicas[i]

      seleccion = datos[col].filter(datos[col].is_not_null())
      values = seleccion.to_list()
      mean_val = np.mean(values)  #Calculamos media
      median_val = np.median(values) #Calculamos mediana
      medianas.append((Caracteristicas[i],median_val)) #Guardamos la mediana

      plt.figure(figsize=(8, 6))
      sns.histplot(x=values, color=colors[i])
      Nombre_de_imagen=f'Histograma de {Caracteristicas[i]}'
      NombresImagenes.append(Nombre_de_imagen)
      plt.title(Nombre_de_imagen)
      plt.ylabel('Valores')
      plt.axvline(mean_val, color='red', linestyle='--', label=f'Media {mean_val:.2f}')  #Ploteamos una linea en donde esta la media
      plt.axvline(median_val, color='blue', linestyle='-.', label=f'Mediana {median_val:.2f}') #Ploteamos una linea en donde esta la mediana
      plt.xlabel(col)
      plt.grid()
      plt.legend()
      plt.tight_layout()
      DireccionesImagenes.append(GuardarImagen(Nombre_de_imagen))

  #Todo bien

  #Ahora eliminamos los valores nulos
  for col,median in medianas:
    datos=datos.with_columns(pl.when(pl.col(col).is_null()).then(median).otherwise(pl.col(col)).alias(col))

  #Vemos un pairplot
  plt.figure(figsize=(10,10))
  sns.pairplot(datos.to_pandas(), hue="delegacion", diag_kind="kde", palette="Set2")
  Nombre_de_imagen="Relaciones entre caracteristicas"
  NombresImagenes.append(Nombre_de_imagen)
  plt.title(Nombre_de_imagen)
  DireccionesImagenes.append(GuardarImagen(Nombre_de_imagen))

  #Veamos las correlaciones con un mapa de calor

  # Convertir solo las columnas numéricas a pandas
  DatosPandas = datos.select(pl.col(pl.NUMERIC_DTYPES)).to_pandas()

  # Calcular la matriz de correlación con pandas
  correlacion = DatosPandas.corr()

  # Crear un mapa de calor con Seaborn
  sns.heatmap(correlacion, annot=True, cmap="coolwarm", fmt=".2f")
  Nombre_de_imagen="Mapa de calor"
  NombresImagenes.append(Nombre_de_imagen)
  plt.title(Nombre_de_imagen)
  DireccionesImagenes.append(GuardarImagen(Nombre_de_imagen))

  #Todo bien

  #Metemos los boxplot ya sin atipicos
  for col in columnas:
      values = datos[col].to_list()
      plt.figure(figsize=(8, 6))
      sns.boxplot(x=values)
      #Guardamos el nombre de la imagen
      Nombre_de_imagen=f'Boxplot de {col}'
      NombresImagenes.append(Nombre_de_imagen)
      plt.title(Nombre_de_imagen)
      plt.ylabel('Valores')
      plt.xlabel(col)
      plt.grid()
      plt.tight_layout()
      #Guardamos la direccion de la imagen
      DireccionesImagenes.append(GuardarImagen(Nombre_de_imagen))

  #Ahora guardamos la imagen de los atipicos por delegacion despues de la limpieza
  plt.figure(figsize=(10,10))
  sns.boxplot(data=datos.to_pandas(),x="precio",y="delegacion")
  Nombre_de_imagen="Boxplot de precios por delegacion limpios"
  NombresImagenes.append(Nombre_de_imagen)
  plt.title(Nombre_de_imagen)
  plt.ylabel('Precio')
  plt.xlabel('Delegación')
  DireccionesImagenes.append(GuardarImagen(Nombre_de_imagen))

  #Guardamos el dataframe en JSON
  datos.to_pandas().to_json(Ruta_JSON[:19]+"_cleaned"+".jsonl", orient="records", lines=True)



  #Ahora ploteamos los mapas de la CDMX por caracteristica


  import geopandas as gpd

  #Enviar (dataframe,caracteristica)
  def Mapa(df,ClavesDel,ValoresMed,caracteristica="precio"):

    #Convertimos el dataframe en uno de pandas si es que no lo está
    MapaDatos=df.to_pandas()

    #Importamos el geo dataframe del archivo shp *******Colocar aqui la direccion***********
    delegaciones_mapa = os.path.join("src", "assets", "poligonos_alcaldias_cdmx.shp")
    gdf_delegaciones = gpd.read_file(delegaciones_mapa)

    #Hacemos que las columnas de nuestro dataframe coincidan con las del geo df
    MapaDatos["delegacion"]=MapaDatos["delegacion"].apply(Unificar)

    # Hacemos un dataframe que tenga calculado el estadistico que queramos utilizar en el mapa, trae la mediana por defecto por los atipicos
    dfAuxiliar = MapaDatos.groupby('delegacion')[caracteristica].median().reset_index()

    #Tenemos que ver si el dfAuxiliar tiene a todas las delegaciones, en caso contrario pondremos un renglon de Null
    Delegaciones=dfAuxiliar["delegacion"].to_list()
    for Delegacion in Delegaciones:
      if Delegacion not in gdf_delegaciones["NOMGEO"].to_list():
        dfAuxiliar.loc[len(dfAuxiliar)] = [Delegacion, None]

    #Probamos lo del dataframe
    #print(dfAuxiliar)

    #Si es de precio lo guardo
    if caracteristica=="precio":
      #print(dfAuxiliar["delegacion"].to_list())
      #print(dfAuxiliar[caracteristica].to_list())
      ClavesDel.extend(dfAuxiliar["delegacion"].to_list())
      ValoresMed.extend(dfAuxiliar[caracteristica].to_list())
      #print(ClavesDel)
      #print(ValoresMed)

    #Unimos el dfAuxiliar con el geo dataframe (Revisa que el nombre de la columna de tus delegaciones se llame delegacion o le cambias aqui)
    gdf_delegaciones = gdf_delegaciones.merge(dfAuxiliar, left_on='NOMGEO', right_on='delegacion', how='left')

    #print(gdf_delegaciones.head())

    #Ploteamos el mapa (Por defecto esta en la paleta viridis)
    fig, ax = plt.subplots(1, 1, figsize=(10, 10))
    gdf_delegaciones.plot(column=caracteristica,ax=ax, legend=True,
                          legend_kwds={'label': f"{caracteristica} medio/a por delegación",
                                      'orientation': "vertical"},
                          cmap='Set2')  # Elige el cmap para los colores
    gdf_delegaciones.boundary.plot(ax=ax, color='black', linewidth=1)
    Nombre_de_imagen=f"Mapa de {caracteristica} Medio por Delegación en CDMX"
    NombresImagenes.append(Nombre_de_imagen)
    plt.title(Nombre_de_imagen)
    DireccionesImagenes.append(GuardarImagen(Nombre_de_imagen))

  #Creamos dos array , uno para los nombres de las delegaciones y otro para las medianas
  ClavesDel=[]
  ValoresMed=[]

  for col in columnas:
    Mapa(datos,ClavesDel,ValoresMed,col)

  return  [dict(zip(NombresImagenes,DireccionesImagenes)),dict(zip(ClavesDel,ValoresMed))]
import os
#GenerarInformacion(os.path.join( "src", "data", "2024-12-20.jsonl"))

